We are very grateful for the reviews and suggestions. We will incorporate them to improve our paper. For clarity, we only answer the major questions.

**Q1:Reproducibility&Verifiability(R#A&#B&#C)**

We distribute the detailed replication package(https://github.com/degraphcs/DeGraphCS), containing [source code](https://github.com/degraphcs/DeGraphCS/tree/main/src), raw [dataset](https://drive.google.com/file/d/1PZ9TAfsrSlXLDpOCp6-0aZQxrzlP4kBA/view?usp=sharing) and preprocessed [dataset](https://github.com/degraphcs/DeGraphCS/tree/main/dataset), all 50 [queries](https://github.com/degraphcs/DeGraphCS/blob/main/user%20study/queries.txt) and the corresponding retrieval [results](https://github.com/degraphcs/DeGraphCS/tree/main/user%20study). We also publish our implementation of [baselines](https://github.com/degraphcs/DeGraphCS/tree/main/Baseline%20methods), which achieve **comparable performance** in our dataset, e.g., for *DeepCS*, we reuse their OSS code and it achieved the same level of performance during the large-scale automatic test process, akin to the process in [***MMAN***](https://ieeexplore.ieee.org/abstract/document/8952337/)\[5].

**Q2:Dataset Scale(R#A&#C)**

The scale of our dataset is restricted by: 1)contrastive experiments with SOTA approach of deep code search, i.e., ***MMAN*** using 28, 527 C code; 2)rigorous preprocessing by compilation, code-length, **de-duplicating**(has not been specified by previous work), etc. Our raw data consists of 151,414 methods from 3,171 C real projects from GitHub. The final dataset with 41,152 snippets(1.44 times larger than ***MMAN***) distributed among 1,554 projects. All the details can be found in our online [replication package](https://github.com/degraphcs/DeGraphCS).

**Q3: LLVMIR Limitation(R#A& #C)**

For some partial codes, it is difficult for LLVM to generate the corresponding IR due to the absence reference of third-party libraries. However, we have provided an actionable [solution](https://github.com/degraphcs/DeGraphCS/blob/main/src/README.md) by auto-generated decorated interfaces for those external functions. For other languages, IR (i.e., intermediate representations we need) can be generated by other techniques, e.g., ***[jimple-of-soot](https://www.sable.mcgill.ca/soot/) and [bytecode](GENERATIVE%20CODE%20MODELING%20WITH%20GRAPHS-ICRL2019.pdf) for Java&Python***. We will work on other languages in future.
